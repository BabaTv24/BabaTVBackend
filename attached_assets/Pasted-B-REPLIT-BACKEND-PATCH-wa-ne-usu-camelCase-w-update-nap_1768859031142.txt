B) REPLIT BACKEND — PATCH (ważne: usuń camelCase w update + napraw login)
1) routes/admin.js — send-invite: update tylko snake_case

W Twoim admin.post("/users/:id/send-invite"... zamień fragment .update({ ... }) na TEN:

const now = new Date().toISOString();

const updatePayload = {
  password_hash,
  must_change_password: true,
  access_status: "active",
  ref_code: refCode,
  external_id: refCode,
  updated_at: now
};

const { error: updateError } = await supabase
  .from(USERS_TABLE)
  .update(updatePayload)
  .eq("id", user.id);


❌ Usuń z update: mustChangePassword, accessStatus, refCode, updatedAt itd.
To jest źródło Twojego błędu schema cache.

2) routes/auth.js — login MUSI używać password_hash (bcrypt)

Jeśli Twoje /api/auth/login teraz sprawdza inną kolumnę albo Supabase Auth — zrób to „na twardo” i stabilnie:

import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET;

auth.post("/login", async (c) => {
  try {
    const { email, password } = await c.req.json();
    const supabase = getSupabaseClient();

    if (!email || !password) {
      return c.json({ success: false, error: "Missing email or password" }, 400);
    }

    const { data: user, error } = await supabase
      .from(USERS_TABLE)
      .select("id, public_id, email, password_hash, must_change_password, access_status, role, sponsor_id, sponsor_public_id, level, ref_code")
      .eq("email", email.toLowerCase().trim())
      .maybeSingle();

    if (error || !user) {
      return c.json({ success: false, error: "Invalid credentials" }, 401);
    }

    if ((user.access_status || "active") !== "active") {
      return c.json({ success: false, error: "Account inactive" }, 403);
    }

    const ok = await bcrypt.compare(password, user.password_hash || "");
    if (!ok) {
      return c.json({ success: false, error: "Invalid credentials" }, 401);
    }

    const token = jwt.sign(
      {
        sub: user.id,
        role: user.role || "user",
        email: user.email,
        public_id: user.public_id,
        sponsor_public_id: user.sponsor_public_id,
        sponsor_id: user.sponsor_id,
        level: user.level,
      },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    return c.json({
      success: true,
      token,
      user: {
        id: user.id,
        publicId: user.public_id,
        email: user.email,
        role: user.role || "user",
        mustChangePassword: !!user.must_change_password,
        sponsorPublicId: user.sponsor_public_id,
        level: user.level,
        refCode: user.ref_code
      }
    });
  } catch (e) {
    return c.json({ success: false, error: e.message }, 500);
  }
});